### What?
No idea. K, idea, somewhat incoherent.


Given a directory structure, messages are processed, using the directory structure
as a map for what messages will be delivered where


#### Definitions
* message - a JSON blob containing information about an event that has taken place
* message source - a path like structure indicating the origin of the message
  and used to to map messages to handlers.
* destination - ultimately messages are routed by making a determination to which
  HTTP URL the message will be posted.  An URL that receives a POSTed message is
  a destination.
* router - a system making decisions about what destinations will receive
  particular messages.  
* subscription repo - subscriptions to events are managed by a git repository containing
  a mapping of event information to URLs that will receive informatino for matching events
  via POST. The subscription repo format is covered more fully below.
* subcription - a subscription is defined by a file containing a JSON object, describing
  at least, the URL to which the message is to be POSTed.


#### Design Choices

* shell scripts - This is new and in flux, making this out of shell scripts makes it
  super simple to adapt 'till we know better what it's gonna look like.
* 'functions' - each shell script in ./bin is analogous to a function that one
  might write in another language.
* passing messages - this referes to 'message' as defined above in Definitions,
  when passing a message into a fuction (shell script) it will be passed in on
  stdin.


#### Logical Process Flow

* `send_message_to_router` - this is the recording of an event.  At this point something has taken place and we'd like to notify folks of that fact.  This event is generated by (most likely) some external system that would like to make known an action that it has taken. Most often this will be in the form of POSTing a message to this service.
* `get_message_from_routing_queue` - some number of processes will be monitoring the routing queue for messages and performing the following 3 steps
* `archive_message_from_routing_queue`
* `queue_notification_tasks_for_message`
* `delete_message_from_routing_queue`
* `get_task_from_queue` - some number of processes will be monitoring the task queue and performing the following 3 steps
* `perform_task`
* `archive_completed_task`
* `delete_message_from_task_queue`
