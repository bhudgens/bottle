#! /usr/bin/env bash
# vim: ft=sh

##############################################################################
# This is where all the action takes place, an inbound message is 
# compared to our message routing rules and a series of notification
# tasks is enqueued in the 'task' queue
##############################################################################

##############################################################################
# This is a, theorectically, simple way to include other scripts ( via source )
# in this one without having included files re-include the includes :)
#
# Any files in the directory where this script is running that match *.inc
# will be in the order returned from the expansion of *.inc, so alphabetical
# ordering.  Thus if you wish to control the order more explicitly you can
# name your includes 01_*.inc, 02_*.inc and so on.
##############################################################################
# begin include processing
MY_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
export INCLUDE_LIST=${INCLUDE_LIST}
for include in ${MY_DIR}/*.inc
do
  INCLUDE_KEY=INCLUDED_${include}
  # if we find that our include key is _not_ already in our include list
  # we'll perform the include
  # this is done by removing $INCLUDE_KEY from $INCLUDE_LIST and comparing
  # the resultant to INCLUDE_LIST, if equal, nothing has been removed and thus
  # $INCLUDE_KEY is not in $INCLUDE_LIST
  if [ "${INCLUDE_LIST//${INCLUDE_KEY}//}" == "${INCLUDE_LIST}" ]
  then
    [ -n "${DEBUG}" ] && echo "including file: ${include}" >&2
    source ${include}
    INCLUDE_LIST=${INCLUDE_LIST}:${INCLUDE_KEY}
  fi
done
# end include processing

# single quotes are perfectly valid JSON, but we're passing the JSON object to
# our cli via '' quoted value, so we'll escape any single quotes
MESSAGE_BODY=$(cat | sed -E -e $'s/\'/\'\\\\\'\'/g')
MESSAGE_SOURCE=$(echo "${MESSAGE_BODY}" | jq --raw-output ".source")
SUBSCRIBER_PATH="${SUBSCRIBER_REPO_DIR}/${MESSAGE_SOURCE}"
debug "subscriber path: ${SUBSCRIBER_PATH}"
for subscriber in $(get_subscribers_for_message "${SUBSCRIBER_PATH}")
do
  debug "does subscriber ${subscriber} want message"
  debug "${MESSAGE_BODY}"
  FILTER=$(cat ${subscriber} | jq --raw-output ".filter")
  if [ -n "${FILTER}" -a "${FILTER}" != "null" ]; then
    debug "using filter ${FILTER}"
    # if the subscriber has provided a filter, it must match or we will not
    # send the message to the subscriber
    CONTAINS=$(echo "${MESSAGE_BODY}" | jq ".messageData" | jq "contains(${FILTER})")
    if [ "true" == "${CONTAINS}" ]; then
      # filter matches
      debug "filter matches!"
    else
      # filter does not match
      debug "filter doesn't match"
    fi
  else
    # no filter, you get the message buddy
    debug "no filter, subscriber ${subscriber} gets message"
  fi
done

#eval ${AWS_CLI} sqs send-message --queue-url ${TASK_QUEUE_URL} --message-body \'${MESSAGE_BODY}\'

